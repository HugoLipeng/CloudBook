# Java垃圾收集算法

1. **标记-清除**算法( *标记出所有需要回收的对象，标记完成后统一回收* )

   > *标记和清除过程效率不高，标记清除之后会产生大量不连续的内存碎片，如果碎片太多，导致运行过程中需要分配较大对象时，无法找到足够连续内存，就得提前触发另一次垃圾收集动作。*
   >
   > ![img](E:\Android_NoteBook\Android_NoteBook\assets\3985563-1b31d5ebe8dec659.png)

2. **复制**算法( *将内存分为两块，回收时将存活的对象的复制过来，然后将另一块中已使用的全部清理*  )

3. **标记-整理** ( *让所有标记过的对象都向一端移动，然后直接清理掉边界以外的内存* )

4. **分代收集** ( *新生代，老年代,->根据各个年代采用最适当的收集算法* )



### 年轻代-老年代

HotSpot JVM把年轻代分为了三部分，1个Eden区和2个Survivor区(分别叫from和to)。

一般情况下，新创建的对象都会被分配到Eden 区(一些大对象特殊处理)，这些对象经过第一次 Minor GC后，如果仍然存活，将会被移到 Survivor(幸存者) 区。对象在 Survivor 区中每熬过一次Minor GC，年龄就会增加1岁，当他的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死(80%以上)， 所以在 **年轻代的垃圾回收算法使用的是复制算法**， 复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另一块上面。复制算法不会产生内存碎片。

在Gc开始的时候，对象只会存在于 Eden区和名为 “From” 的Survivor区，Survivor区“To”是空的。紧接着进行Gc，Eden 区中所有存活的对象都会被复制到 “To” ,而在 “From” 区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过 -xx:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From” 和 “To” 会交换它们的角色，也就是新的 “To” 就是上次Gc 前的“From”，新的 "From" 就是上次GC 前的 “To” 。不管怎样，都会保证名为 To 的Survivor 区域是空的。Minor Gc 会一直重复这样的过程，直到 “To” 区被填满，“To” 区被填满之后，会将所有对象移动到年老代中。



### Minor GC和Full GC的区别

Minor GC:指发生在新生代的垃圾收集动作，该动作非常频繁。

Full GC/Major Gc：指发生在老年代的垃圾收集动作，出现了Major GC,经常会伴随至少一次的 Minor GC。