# 视频补课

## Activity

Scheme 跳转协议，网页跳转app，或者从app内部跳转到别的页面，或者从通知栏或者别的app跳转。



## Fragment

#### 加载方式

1. xml加载

2. 代码动态加载

   > 动态在activity中添加fragment
   >
   > ```java
   > //创建Fragment
   > Fragment fragment=new Fragment();
   > //获取FragmentManager
   > FragmentManager fragmentManager=getSupportFragmentManager();
   > //开启事务
   > FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
   > //添加或替换碎片
   > fragmentTransaction.replace(id,fragment);
   > //提交事务 
   > fragmentTransaction.commit();
   > ```



#### FragmentPagerAdapter与 FragmentStatePagerAdapter

> 前者会保存数据，适用于页面较少。源码中最后调用 detach,即只是与Activity View分离。
>
> 后者不保存数据，适用于页面较多。切换页面时会回收内存，即remove掉了。



#### 生命周期

![img](E:\Android_NoteBook\Android_NoteBook\assets\945877-20161123093212096-2032834078.png)



#### Fragment通信

1. 在fragment中调用Activity的方法  getActivity

2. 在Activity中调用 Fragment中的方法   接口回调

3. 在fragment中 调用 fragment中的方法 findFragmentById

   ```java
   getFragmentManager().findFragmentById(id)
   ```



#### Fragment的 replace,add，remove方法

這些方法其实都是FragmentManager(用来管理Fragment)的方法。

- replace，替換
- add 添加
- remove 移除



## WebView

> webView在布局中使用，webview写在其他容器中时。
>
> webview销毁时，记得先从view中remove掉，再销毁webview.
>
> jsbridge:用于与h5进行互调。
>
> webview后台耗电：
>
> webview硬件加速导致页面渲染问题。（只能关闭硬件加速）
>
> webview 添加context使用弱引用,动态添加webiew 



## Server

#### Server是什么？

Server是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。而且Server一旦被启动，即使当前启动的Activity被销毁，服务依然存活。Server里面不能做耗时操作。



#### Server和Thread的区别？

Thread是程序运行的最小单元，是cpu分配的最小单元。Server运行时在主线程，是一个在后台操作而没有用户界面的组件。 使用Server你可以更好的控制后台任务，而线程却不受控制。

实际开发中：线程一般指的工作线程。而server不适合做耗时操作。

应用场景：需要访问网络，或者读取数据库等，一般采用子线程，如果需要定时刷新，音乐视频等，需要Server



#### Server生命周期

- oncreate()   首次创建服务时，系统将会调用
- onStartCommand  每次startService() 启动 调用此方法
- onDestroy  服务回收
- onBind 绑定服务

需要注意的是 onStartCommand的返回值，有三种不同结果。一种是默认的。一种是会在系统杀掉之后尝试重新启动。另一种是重新启动之后，并返回intent.



1. #### startService（启动服务）

   - 定义一个类继承Service
   - 在Manifest.xml文件中配置该Service
   - 使用Context的 startService(Intent)方法启动该Service
   - 不再使用时，调用 stopService(Intent)方法停止该服务。

2. #### bindService(绑定服务)

   - 创建BindService服务端，继承自Service并在类中，创建一个实现IBinder接口的实例对象并提供公共方法给客户端调用。
   - 从 OnBind() 回调方法返回Binder实例
   - 在客户端中，从onServiceConnected() 回调方法接受Binder,并使用提供的方法调用绑定服务。



 



## Broadcast Receiver

#### 广播定义：

Android 中广泛运用的在应用程序之间传输信息的机制，Android中我们要发送的广播是一个 Intent ，这个Intent 可以携带我们要传送的数据。

#### 广播使用场景：

- 同一个APP具有多个进程的不同组件之间的消息通信。
- 不同App之间的组件之间消息通信。

#### 广播种类

- 标准广播：
- 有序广播：
- 本地广播

#### 实现广播的方式

1. 静态注册：注册完成后一直运行。app销毁后，依然可以收到广播，在xml中邪。
2. 动态注册：跟随activity的生命周期。在代码中动态调用。

#### 广播内部实现机制

1. 自定义广播接收者 BroadcastReceiver,并覆写 onRecvice() 方法。
2. 通过Binder机制AMS（Activity Manager Service）进行注册。
3. 广播发送者通过Binder 机制想AMS发送广播
4. AMS 查找符合相应条件(IntentFilter/Permission等) 的 BroadcastReceiver,将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中。
5. 消息循环执行拿到此广播，回调 BroadcastReceiver 中的 onReceiver()方法。



#### LocalBroadcastManager（本地广播）

1. 安全性；
2. 其他APP无法对你发送广播，因为本地广播无法接受非自身应用发送饿的该广播。，因此不必担心有安全漏洞可以利用。
3. 比系统全局广播更加高效。





## Binder

####  Linux内核基础

- 进程隔离/虚拟地址空间
- 系统调用
- binder驱动





## 移动架构

#### 9、MVP，MVVM，MVC解释和实践

##### MVC:

- 视图层(View) 对应于xml布局文件和java代码动态view部分
- 控制层(Controller) MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。
- 模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网络请求，数据库处理，I/O的操作。

##### 总结

具有一定的分层，model彻底解耦，controller和view并没有解耦 层与层之间的交互尽量使用回调或者去使用消息机制去完成，尽量避免直接持有 controller和view在android中无法做到彻底分离，但在代码逻辑层面一定要分清 业务逻辑被放置在model层，能够更好的复用和修改增加业务。

##### MVP

通过引入接口BaseView，让相应的视图组件如Activity，Fragment去实现BaseView，实现了视图层的独立，通过中间层Preseter实现了Model和View的完全解耦。MVP彻底解决了MVC中View和Controller傻傻分不清楚的问题，但是随着业务逻辑的增加，一个页面可能会非常复杂，UI的改变是非常多，会有非常多的case，这样就会造成View的接口会很庞大。

##### MVVM

MVP中我们说过随着业务逻辑的增加，UI的改变多的情况下，会有非常多的跟UI相关的case，这样就会造成View的接口会很庞大。而MVVM就解决了这个问题，通过双向绑定的机制，实现数据和UI内容，只要想改其中一方，另一方都能够及时更新的一种设计理念，这样就省去了很多在View层中写很多case的情况，只需要改变数据就行。

##### MVVM与DataBinding的关系？

MVVM是一种思想，DataBinding是谷歌推出的方便实现MVVM的工具。

看起来MVVM很好的解决了MVC和MVP的不足，但是由于数据和视图的双向绑定，导致出现问题时不太好定位来源，有可能数据问题导致，也有可能业务逻辑中对视图属性的修改导致。如果项目中打算用MVVM的话可以考虑使用官方的架构组件ViewModel、LiveData、DataBinding去实现MVVM。

##### 三者如何选择？

- 如果项目简单，没什么复杂性，未来改动也不大的话，那就不要用设计模式或者架构方法，只需要将每个模块封装好，方便调用即可，不要为了使用设计模式或架构方法而使用。
- 对于偏向展示型的app，绝大多数业务逻辑都在后端，app主要功能就是展示数据，交互等，建议使用mvvm。
- 对于工具类或者需要写很多业务逻辑app，使用mvp或者mvvm都可。

### 插件化

#### 解决问题

1. 动态加载APK  (宿主APP去加载)
2. 资源加载
3. 代码加载

DexClassLoader 





### 进程保活

1. 利用系统广播拉活
2. 利用系统Service机制拉活
3. 利用Native进程拉活





## HandlerThread

Handler+thread+looper，内部有一个looper

它是一个Android封装好的轻量级异步通信库。

用于实现在工作线程中执行任务，如耗时任务。

异步通信，消息传递等。





### AsyncTask的缺陷和问题

AsyncTask是一种轻量级的异步任务类，他可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程更新UI。

AsyncTask是一个抽象的泛型类，我们再使用时，需要继承相应的抽象类，并传入相应的类型，其中，Params表示参数的类型，Progress表示后台任务的执行进度和类型，而Result则表示后台任务的返回结果类型。如果AsyncTask不需要传递具体的参数，那么这三个泛型参数都可以用void来代替。

AnsyncTask内部的线程池是一个核心线程数为CPU+1，最大线程数为CPU*2+1.工作队列长度为128的线程池，线程池等待队列的最大等待数为28，但是可以自定义线程池。





#### Android中进程优先级

1. 前台进程
2. 可见进程
3. 服务进程
4. 后台进程
5. 空进程



### Android各版本新特性

#### Android5.0

- MD设计风格
- 支持64位art编译器
- 通知详情自定义

#### Android6.0

- 动态权限
- 快速充电
- 相机专业模式

#### Android7.0

- 多窗口
- DOZE(解决耗电问题)
- 夜间模式

### Android8.0

- 优化通知
- 画中画模式
- 后台限制

### Android9.0

- 刘海屏支持
- 禁止http
- 安全增强
- 室内wifi定位
- 生物识别加强

### Android10.0

- 夜间模式
- 桌面模式







