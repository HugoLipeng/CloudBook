# 关于协程中的并发问题 | Kotlin



## 背景

协程可以帮助我们自由的切换线程，但是由于协程是运行在 **Java线程模型** 基础之上，所以也无可避免的存在并发问题。

所有并发问题的源头都是因为 **状态管理** 的不一致性。在多线程的情况下，操作执行的顺序是不可预测的。与编译器优化操作的顺序不同，线程无法保证以特定的顺序运行，而上下文切换的操作随时有可能发生。所以如果在访问一个未经处理的状态时，线程很有可能就会访问到过时的数据，丢失必要的更新，或者遇到 **资源竞争** 等情况。

所以 **使用了协程并且涉及可变状态的类必须采取措施使其可控**，比如保证协程中的代码所访问的数据是最新的。这样一来，不同的线程之间就不会互相干扰。

## 模拟协程中的并发问题

**示例代码**

```kotlin
fun main() =
    runBlocking {
        var sum = 0
        
        @Synchronized
        fun addSum() {
            ++sum
        }

        val time = measureTimeMillis {
            coroutineScope {
                (0..100000).forEach { _ ->
                    launch(context = Dispatchers.IO) {
                        delay(3)
                        addSum()
                    }
                    launch(context = Dispatchers.IO) {
                        delay(3)
                        addSum()
                    }
                }
            }
        }
        println("runTime-----$time")
        println(sum)
    }
```

看一下打印结果。

```
runTime-----1337
181078
```

> 我们在 forEach 中使用了两个子协程，并且使用了IO调度器，每次执行到这里，协程内部线程池都可能会调用新的线程任务去执行任务，所以最终的结果不难理解。

虽然说协程默认作用域是同步处理，我们一般也不会写出上述demo,但是一旦牵扯到可更改的状态，比如某个方法内部切换了协程作用域，那么为了安全的状态，我们势必要加一些额外的处理。

---



## 处理并发问题

对于如何处理并发问题，其实也就是如何保护状态的可变。

这个问题往往取决于具体的业务逻辑，不过通用的方式如下：

### 封装

可变状态封装在类里，该类的将状态的访问操作集中起来，根据实际业务场景使用同步策略保护变量的访问和修改操作。

### 线程限制

将读取和写入限制在一个线程中，比如使用生产-消费者模式对可变状态的访问。

### 间接或者包装解决

对于一些可变状态改变，使用 **@Volatile** 也可以起到很好的效果，或者也可以使用 [AtomicInteger](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html) ，或者 ConcurrentHashMap。

但注意，除了 @Volatile ，其他的数据结构都无法保证具体的调用顺序问题，它们只能确保数据的访问是原子性操作。不过对于简单的处理，这种方式可以让我们避免使用 `lock` 或者 `Synchronized`。

### 自定义方案

如果有复杂的业务逻辑需要同步处理，那么上述的处理方式可能也无法解决。在这种情况下，可能需要我们创建自己的并发工具类，比如使用AQS，或者 Mutex。

`Kotlin` 中， `Mute` ,其包含挂起函数 `lock` 与 `unlock` ,可以手动控制保护程序的代码，或者也可以使用扩展函数 `withLock()` ，在协程中使用更适合这种复杂场景。

更改示例代码如下所示：

```kotlin
...
 val mutex = Mutex()
        suspend fun addSum() {
            
            //1.使用 lock与unLock 
            mutex.lock()
            ++sum
            mutex.unlock()
            
          
            //2.使用扩展函数withLock
            mutex.withLock {
                ++sum
            }
        }
...
```

使用 `Mutex` 的协程可以在执行前会挂起，相比普通的 `Lock` 锁高效很多。因为非协程的处理方式，比如Synchronized，Lock 会直接阻塞当前线程，这些处理方式将引发[活跃度问题](https://segmentfault.com/a/1190000017915735)。也就是导致线程并不能及时处理问题，虽然说最终也可以处理，但是损耗了一定时间。 



传入协程中的代码最终会在一个或多个线程中执行，同样的，协程在Android 运行时的线程模型下依然需要遵循一定的使用约束，所以对于共享的可变状态，在操作时我们仍要谨慎访问。





## 参考

[深入浅出协程、线程和并发问题](https://juejin.cn/post/6969408505694388237#heading-1)

