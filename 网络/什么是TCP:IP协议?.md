# 什么是TCP/IP协议?

> 计算机与网络设备之间如果要相互通信,双方就必须基于相同的方法.比如如何探测到通信目标.由哪一边先发起通信,使用哪种语言进行通信,怎样结束通信等规则都需要事先确定.不同的硬件,操作系统之间的通信,所有这一切都需要一种规则.而我们就将这种规则称为协议 (protocol).

![image-20191027150025587](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2nevm43j30kg08taaf.jpg)

也就是说，TCP/IP 是互联网相关各类协议族的总称。



### TCP/IP 的分层管理

TCP/IP协议里最重要的一点就是分层。TCP/IP协议族按层次分别为 **应用层，传输层，网络层，数据链路层，物理层**。当然也有按不同的模型分为4层或者7层的。

#### 为什么要分层呢？

> 把 TCP/IP 协议分层之后，如果后期某个地方设计修改，那么就无需全部替换，只需要将变动的层替换。而且从设计上来说，也变得简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方，怎样传输，如果确保到达率等问题。

![image-20191027150352733](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2o8bbz3j30bj0cg0t9.jpg)

如上图所示，我们将TCP/IP分为5层，越靠下越接近硬件。我们由下到上来了解一下这些分层。

1. **物理层** 

   该层负责 比特流在节点之间的传输，即负责物理传输，这一层的协议既与链路有关，也与传输的介质有关。通俗来说就是把计算机连接起来的物理手段。

2. **数据链路层** 

   控制网络层与物理层之间的通信，主要功能是保证物理线路上进行可靠的数据传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据结构的结构包，他不仅包含原始数据，还包含发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传达数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

3. **网络层** 

   决定如何将数据从发送发路由到接收方。网络层通过综合考虑发送优先权，网络拥塞程度，服务质量以及可选路由的花费等来决定从网络中的A节点到B节点的最佳途径。即建立主机到主机的通信。

4. **传输层** 

   该层为两台主机上的应用程序提供端到端的通信。传输层有两个传输协议：TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，udp是不可靠的或者说无连接的协议

5. **应用层**

   应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定应用程序的数据格式。主要的协议有：HTTP.FTP,Tnlent等。



### TCP与UDP

TCP/UDP 都是传输层协议，但是两者具有不同的特效，同时也具有不同的应用场景。

![image-20191027212512703](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2tjs2owj30l50d3dji.jpg)

#### 面向报文

面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。

#### 面向字节流

虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应该程序传送的数据块太长，TCP就可以把它划分短一些再传送。



#### TCP的三次握手与四次挥手

具体过程如下：

- **第一次握手**：建立连接。客户端发送连接请求报文段，并将syn(**标记位**)设置为1，Squence Number(**数据包序号**)(seq)为x,接下来等待服务端确认，客户端进入SYN_SENT状态(**请求连接**)；

- **第二次握手**：服务端收到客户端的  SYN 报文段，对 SYN 报文段进行确认，设置 ack(**确认号**)为 x+1(即seq+1 ; 同时自己还要发送 SYN 请求信息，将 SYN 设置为1, seq为 y。服务端将上述所有信息放到 SYN+ACK 报文段中，一并发送给客户端，此时服务器进入 SYN_RECV状态。

  > *SYN_RECV*是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入[ESTABLISHED](https://baike.baidu.com/item/ESTABLISHED/7327079)状态。

- **第三次握手**：客户端收到服务端的 SYN+ACK(确认符) 报文段；然后将 ACK 设置为 y+1,向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED(**连接成功**)状态，完成TCP 的三次握手。

上面的解释可能有点不好理解，用《图解HTTP》中的一副插图 帮助大家。

![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2p3odp9j30i409474y.jpg)



***当客户端和服务端通过三次握手建立了 TCP 连接以后,当数据传送完毕,断开连接就需要进行TCP的四次挥手。其四次挥手如下所示：***

- **第一次挥手**

  客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1 状态，表示客户端没有数据要发送给服务端了。

- **第二次挥手**

  服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。

- **第三次挥手**

  服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。

- **第四次挥手**

  客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。

**最后再看一下完整的过程：**

**![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2p2s7kgj308r09tdgc.jpg)**

> **如果有大量的连接，每次在连接，关闭都要经历三次握手，四次挥手，这显然会造成性能低下。因此。Http 有一种叫做 长连接（keepalive connections） 的机制。它可以在传输数据后仍保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次握手。**
>
> **![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8d2p33u7bj30l802qq2y.jpg)**



### 一些问题汇总：



##### 1. 为什么要三次握手？

> 为了防止已失效的连接请求报文突然又传送到了服务端，因为产生错误。
>
> 具体解释：  “**已失效的连接请求报文段**”产生情况：
>
> client 发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留，因此导致延误到连接释放以后的某个时间才到达 service。如果没有三次握手，那么此时server收到此失效的连接请求报文段，就误认为是 client再次发出的一个新的连接请求，于是向 client 发出确认报文段，同意建立连接，而此时 client 并没有发出建立连接的情况，因此并不会理会服务端的响应，而service将会一直等待client发送数据，因此就会导致这条连接线路白白浪费。
>
> 
>
> **如果此时变成两次挥手行不行？**
>
> 这个时候需要明白全双工与半双工，再进行回答。比如：
>
> - 第一次握手： A给B打电话说，你可以听到我说话吗？
> - 第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？  
> - 第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！
>
> 　**在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。** **这样，就可以开始正常通信了。**如果是两次，那将无法确定

##### 2. 为什么要四次挥手？

> TCP 协议是一种面向连接，可靠，基于字节流的传输层通信协议。TCP 是全双工模式(同一时刻可以同时发送和接收)，这就意味着，当主机1发出  FIN 报文段时，只是表示主机1已结没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 ACK报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会中断这次TCP连接。

##### 3.为什么要等待 2MSL

> **MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间
>
> 原因如下：
>
> - 保证TCP协议的全双工连接能够可靠关闭
> - 保证这次连接的重复数据从网络中消息
>
> 第一点： 如果主机1直接 关闭，由于IP协议的不可靠性或者其他网络原因，导致主机2没有收到主机1最后回复的 ACK。那么主机2就会在超时之后继续发送 FIN，此时由于主机1已经关闭，就找不到与重发的 FIN 对应的连接。所以，主机1 不是直接进入 关闭，而是TIME_WAIT 状态。当再次收到 FIN 的时候，能够保证对方收到  ACK ，最后正确关闭连接。
>
> 第二点：如果主机1直接 关闭，然后又再向主机 2 发起一个新连接，我们不能保证这个新连接与刚才关闭的连接端口是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但还是有特殊情况出现；假设新连接和已经关闭的老连接端口号是一样的，**如果前一次连接的某些数据仍然滞留在网络中( Lost Duplicate )**，那些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP 协议就认为哪个延迟的数据时属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在 TIME_WAIT 状态等待两倍 MSL ，保证本次连接的所有数据都从网络中消失。
