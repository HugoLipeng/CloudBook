# 垃圾回收机制

传统的C、C++等编程语言，需要程序员负责回收已经分配的内存。显示进行垃圾回收是一件比较困难的事情，因为程序员并不总是知道内存应该何时被释放。如果一些分配出去的内存得不到及时回收，就会引起系统运行速度下降，甚至导致程序瘫痪，这种现象称之为内存泄漏。

显示进行垃圾回收主要有两个缺点：

- 程序忘记及时回收无用内存，从而导致内存泄漏，降低系统性能。
- 程序错误的回收程序核心类库的内存，从而导致系统崩溃。

Java 程序的内存分配和回收都是由 JRE 在后台自动进行的。Jre 会负责回收那些不再视同的内存。这种机制被称为垃圾回收。（GC）.通常 JRE 会提供一个后台线程来进行检测和控制，一般都是在 cpu 空闲或 内存不足是自动进行垃圾回收，这些操作都是由  jvm决定的。

Java的堆内存是一个运行时数据区，用以保存类的实例(对象)，Java虚拟机的堆内存中存储着正在运行的应用程序锁建立的所有对象，这些对象不需要程序通过代码来显式的释放。 一般来说，堆内存的回收由垃圾回收来负责，所有 的 jvm实现都有一个由垃圾回收管理的堆内存。垃圾回收是一种动态存储管理技术，它自动释放不再被程序引用的对象，按照特定的垃圾回收算法来实现内存资源的自动回收功能。

在 C/C++中，对象所占用的内存不会被自动释放，㘝程序没有显示释放对象所占用的内存，对象所占用的内存就不能分配给其他对象，该内存在程序结束运行之前将一直被占用。 而在 Java中，当没有引用变量指向原先分配给某个对象的内存是，该内存便成为垃圾。Jvm 的一个超级线程会自动释放该内存区。 垃圾回收意味着程序不再需要的对象时 “垃圾信息”，这些信息将被丢弃。

**当一个对象不再被引用时，内存回收它占领的空间，以便空间被后来的新对象使用**。事实上，除了释放没用的对象外，垃圾回收也可以清除内存记录多碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存区。碎片整理将所占用的堆内存移到堆的一端，JVM 将整理出的内存分配给新的对象。

垃圾回收能自动释放内存空间，减轻编程的负担。这使Java虚拟机具有两个显著的特点。

- 垃圾回收机制可以很好的提高编程效率。在没有垃圾回收机制时，可能要花许多时间来解决一个难懂的存储器问题。在用 Java语言编程时，依靠垃圾回收机制可大大缩短时间。
- 垃圾回收机制保护程序的完整性，垃圾回收是 Java 语言安全性策略的一个重要部分。

垃圾回收的一个潜在缺点是它的开销影响程序性能。Java虚拟机必须跟踪程序中有用的对象，才可以确定哪些对象时无用的对象，并最终释放这些无用的对象。这个过程需要花费处理器的时间，其次是垃圾回收算法的不完备性。

Java 语言规范没有明确的说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本的事情；**发现无用的对象，回收被无用对象占用的内存空间，使该空间可被程序再次使用。**



#### 垃圾回收的特点

- 垃圾回收机制的工作目标是回收无用对象的内存空间，这些内存空间都是 JVM 堆内存里的内存空间，垃圾回收只能 回收内存资源，对其他物理资源，如数据库连接，磁盘 I/O 等资源则无能为力。
- 为了更快的让垃圾回收机制回收那些不再使用的对象，可以将该对象的引用变量都设置为 null,通过这种方式按时垃圾回收机制可以回收该对象。
- 垃圾回收发生的不可预知性。由于不同 JVM 采用了不同的垃圾回收机制和不同的垃圾回收算法，因此他有可能是定时发生的，有可能是当 CPU空闲时发生的，也有可能和原始的垃圾回收一样，等到内存消耗出现极限时发生。这和垃圾回收实现机制的选择及具体的设置都有关系。虽然可以调用 Runtime对象的 gc或 System.gc() 等方法来建议系统进行垃圾回收，但这种仅仅只是建议.
- 垃圾回收的精确性主要包括两个方面：一是垃圾回收机制能够精确的标记活着的独享；二是垃圾回收器能够精确的定位对象之间的引用关系。前者是完全回收所有废弃对象的前提，否则就可能造成内存泄漏。而后者则是实现归并和赋值等算法的必要条件，通过这种引用关系，可以保证所有对象都能被可靠的回收，所有对象都能被重新分配，从而有效的减少内存碎片的产生。
- 现在的 JVM 都有两种不同的垃圾回收实现，每种回收机制因其算法差异可能标线各异，有的当垃圾回收运行时允许应用程序的线程运行，还有的在同一时间允许垃圾回收多线程运行。

> 当编写Java 程序时，一个基本的原则时，对于不再需要的对象，不要引用他们，如果保持对这些对象的引用，垃圾回收机制暂时不会回收该独享，则会导致系统可用内存越来越少；当系统可用内存越来越少时，垃圾回收执行的效率就越来越高，从而导致系统的性能下降。





## 对象与垃圾回收

> 当程序创建对象吗，数组等引用类型实体时，系统都会在堆内存中为之分配一块内存区，对象就保存在这块内存区中，当这块内存不再被任何引用变量引用时，这块内存就变成了垃圾，等待垃圾回收机制进行回收。垃圾回收机制具有如下特征。
>
> - 垃圾回收只负责堆内存中的对象，不会回收任何物理资源(例如数据库连接，网络Io等资源)。
> - 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性的失去引用后，系统就会在合适的时候回收它所占的内存。
> - 在垃圾回收机制回收任何对象之前，总会先调用它的 finalize() 方法，该方法可能使该对象重新复活(让一个引用变量重新引用该对象)，从而导致垃圾回收机制取消回收。
>
> ##### 对象在内存中的 状态 
>
> 当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成如下三种：
>
> - 可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的实力变量和方法。
>
> - 可恢复状态:如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存。在回收该对象之前，系统会调用所有可恢复状态对象 的 finalize() 方法进行资源清理。如果系统在调用 finalize() 方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态，否则该对象将进入不可达状态。
>
> - 不可达状态： 当对象和所有引用变量的关联被切断，该系统已经调用所有对象的 finalize() 方法后依然没有使该对象变为可达状态，那么这个对象将永久的失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占用的资源。
>
> - ![1554293663234](C:\Users\yunyang\AppData\Roaming\Typora\typora-user-images\1554293663234.png)
>
>   **一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实力变量引用。当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象被其他对象的实力变量引用时，只有当该对象被销毁后，该对象才会进入可恢复状态。**

##### 是否可以强制垃圾回收？

> 可以，但这种强制回收只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。
>
> - System.gc()
> - Runtime.getRuntime().gc()

##### 简单讲一下 finalize() 方法？

> 在垃圾回收机制回收某个对象所占用的内存之前，通常要求程序调用适当的方法来清理资源，在没有明确指定清理资源的情况下,jAVA 提供了默认机制来清理该对象的资源，这个机制就是 finalize() 方法。
>
> 任何类都可以重写 Object 类的 finalize() 方法，在该方法中清理该对象占用的资源。如果程序终止之前始终没有进行垃圾回收，则不会调用失去引用对象的 finalize() 方法来清理资源。垃圾回收机制合适调用对象的 finalize() 方法是完全透明的，只有当程序认为需要更多的额外内存时，垃圾回收机制才会进行垃圾回收。因此，完全有可能出现这样一种情形：某个失去引用的 对象 只占用了 少量内存，而且系统没有产生严重的内存需求，因此垃圾回收机制并没有试图回收该对象所占用的资源，所以该对象的 finalize() 方法也不会得到调用。
>
> finalize() 具有如下特点：
>
> - 永远不要主动调用某个对象的 finalize() 方法，该方法应交给垃圾回收机制调用。
> - finalize() 方法何时被调用，是否被调用具有不确定性，不要把 finalize() 方法当成一定会执行的方法。
> - 当 JVM 执行可恢复对象的 finalize() 方法时，可能使该对象或系统中其他对象重新编程可达状态。
> - 当 JVM 执行 finalize() 方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。

#### 简单说一下对象的软，弱，虚引用？

1. 强引用

   Java中最常见的引用方式，程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象或一个以上的引用变量所引用时，突然处于可达状态，它处于可达状态，不可能被系统垃圾回收机制回收。

2. 软引用

   软引用 需要通过 SoftRefernce 类来实现，当一个对象只有软引用时，他有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，系统也可使用该对象，当系统内存空间不足时，系统可能回收它。软引用通常用于对内存敏感的程序中。

3. 弱引用

   弱引用通过 WeakReference 类实现，弱引用和软引用很像，但弱引用的引用级别很低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，他就会立即被回收——正如那些失去引用的对象一样，必须等到垃圾回收机制运行时才会被回收。

4. 虚引用

   虚引用通过 PhantomRefrence 类实现，需引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列(RefrenceQueue) 联合使用。

   > ```java
   > public class OK {
   >     public static void main(String[] args) {
   >         //创建字符串对象
   >         String str=new String("Petterp");
   >         //创建一个引用队列
   >         ReferenceQueue rq=new ReferenceQueue();
   >         //创建一个虚引用，让此虚引用引用到 str 字符串
   >         PhantomReference pr=new PhantomReference(str,rq);
   >         //切断 str 引用和 "Petterp" 字符串之间的引用
   >         str=null;
   >         System.out.println(pr.get());
   >         System.gc();
   >         System.runFinalization();
   >         //垃圾回收之后，虚引用将被放入引用队列中
   >         System.out.println(rq.poll()==pr);
   >     }
   > }
   > ```

使用这些引用类可以避免在程序执行期间将对象留在内存中。如果以软引用，弱引用或虚引用的方法引用对象，垃圾回收期就能随意的释放对象。如果希望尽可能减少程序在其声明周期中所占用的内存大小时，这些引用类就很有用处。

由于垃圾回收的不确定性，当程序希望从软，弱引用中取出被引用对象时，可能这个被引用对象已经被释放了。如果程序需要使用那个被引用的对象，则必须重新创建该对象。