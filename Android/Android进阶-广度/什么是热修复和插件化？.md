# 什么是热修复和插件化？



### 热修复解决的问题？

1. 刚发布应用时发现了较严重的 bug
2. 小功能的更新推送(比如某些特定节日的应用样式)

改变我们的结构

### 插件化解决的问题？

1. 应用过大
2. 合作开发时的问题





# Class文件

### 什么是Class文件？

> 能够被JVM识别，加载并执行的文件格式



#### 如何生成一个class文件？

- 通过IDE自动build生成
- 通过java c生成，即编译命令
- 通过 java 命令执行



#### class文件的作用

- 记录一个类文件的所有信息



#### class文件格式详解

- 一种8位字节的二进制流文件
- 各个数据结构按顺序紧密的排列，无间隙
- 每个类或接口都单独占据一个 class 文件



#### class文件具体结构

![image-20191117145711108](https://tva1.sinaimg.cn/large/006y8mN6ly1g911mbwwhvj31bu0u04fr.jpg)



http://http://47.93.207.151//Shiyihui/comments-teach-cass.git





# Dex文件

#### 什么是Dex文件

能够被DVM识别，加载并执行的文件格式；



#### 获取一个Dex文件的方法

1. IDE执行

2. 命令行

   ```
   ./dx --dex --output=Hello.dex hello.class
   ./dexdump -d Heelo.dex
   ```

   

#### Dex文件结构

- 一种8位字节的二进制流文件
- 各个数据按顺序紧密排列，无间隙
- 整个应用所有的java源文件都在一个Dex中(不包含分包情况下)



如下：

![image-20191120220533090](/Users/petterp/Library/Application%20Support/typora-user-images/image-20191120220533090.png)



#### class与Dex对比

- 本质都是一样的，dex是从 class 文件演变而来
- class 文件存在许多冗余信息，dex会去除冗余信息

![image-20191120220807663](https://tva1.sinaimg.cn/large/006y8mN6ly1g94uxn5r4bj313d0u0kfp.jpg)





# JVM

为什么要学习Java虚拟机？

> Android的davlink和art都是基于jvm，所以学习java虚拟机是了解Java虚拟机的必须。



### Java虚拟机结构解析

#### JVM整体结构

![image-20191120222605769](https://tva1.sinaimg.cn/large/006y8mN6ly1g94vgb16pqj31ec0pkaq3.jpg)





#### 一个完整的编译流程

![image-20191120222736764](https://tva1.sinaimg.cn/large/006y8mN6ly1g94vhvrh88j31h20iuh5o.jpg)



#### Java类加载器

- 引导类加载器(BootStrapClassLoader)
- 扩展类加载器(ExClassLoader)
- 系统类加载器(ApplicationClassLoader)
- 自定义类加载器

> **双亲委托机制，全盘负责机制，缓存机制**,

> 过程： **加载-连接(验证-准备-解析)-初始化**
>
> 1. 加载
>
>    将类的信息(字节码)从文件中获取并载入到JVM的内存中
>
> 2. 连接
>
>    验证：检查读入的结构是否符合JVM规范
>
>    准备：分配一个结构来存储类的信息
>
>    解析：将类的常量池中的所有引用改变成直接引用
>
> 3. 初始化
>
>    执行静态初始化程序,把静态变量初始化成指定的值

#### java内存空间

##### Java栈区

- 存放Java方法执行时的所有数据
- 由栈帧组成，一个栈代表一个方法的执行

##### java栈帧

每个方法从调用到执行完成就对应一个栈帧在虚拟机栈中入栈到出栈

每个栈帧一般包括如下：

- 函数的返回地址和参数

- 临时变量：函数的非静态局部变量以及编译器自动生成的一些临时变量

- 栈操作数

  > 局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。

- 动态链接（符号引用和直接引用在运行时进行**解析和链接的过程**，符号引用就相当于名字，存放在java字节码中）



##### 本地方法栈

本地方法栈专门为native方法服务。



##### 方法区

存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后等数据



#####  堆区

所有通过new创建的对象的内存都在堆中分配

是虚拟机中最大的一块内存，也是GC要回收的部分；



#### 垃圾收集算法

- 引用计数
- 可达性分析
- 年代划分
- 标记-复制
- 标记-清除



# Android ClassLoader

- BootClassLoader
- PathClassLoader
- DexClassLoader
- BaseDexClassLoader

###  打印ClassLoader

```java
   //获取当前ClassLoader
        ClassLoader classLoader=getClassLoader();
        if (classLoader != null) {
            Log.e("demo",classLoader.toString());
            //获取父ClassLoader  双亲委托机制
            while (classLoader.getParent()!=null){
                classLoader=classLoader.getParent();
                Log.e("demo","父："+classLoader.toString());
            }
        }
```

结果：

![image-20191120233658144](https://tva1.sinaimg.cn/large/006y8mN6ly1g94xi1u1lnj30t6031aaj.jpg)



### 特点及作用

- 双亲代理模式   (按层级加载，从最顶级开始，如果加载了直接返回，否则向下传递)
- 类加载的共享功能  (缓存机制)
- 类加载的隔离功能  (如果某个类被加载，将直接返回，避免二次修改)



### ClassLoader源码解析

双亲代理模式

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
        // First, check if the class has already been loaded
         //查看自身是否加载过这个类
        Class<?> c = findLoadedClass(name);
       
        if (c == null) {
            try {
            		//查看它的父加载器是否加载过这个类文件
                if (parent != null) {
                    c = parent.loadClass(name, false); 
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }
						
						//如果都没有加载过，那么去Dex中查找这个类
            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                c = findClass(name);
            }
        }
        return c;
}
```

```java
//这里可以看出，并没有实现，主要是为了交给子类去实现
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```



现在我们看一下BaseDexClassLoader的一些子类是怎么实现的：

**DexClassLoader**

![image-20191121000739855](https://tva1.sinaimg.cn/large/006y8mN6ly1g94ydzdhrxj30pa09e0uh.jpg)

```java
public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }
}
```

[官方参考链接](https://developer.android.com/reference/dalvik/system/DexClassLoader?hl=en)



**PathClassLoader**

相比DexClassLoader，只能加载安装到系统的Dex文件

参数，（dex，父类加载器）

```java
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }

    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }
}
```





### 动态加载难点

- 有许多组件类需要注册才能使用
- 资源的动态加载复杂
- Android版本问题





# 热修复入门

#### 什么是热修复？

> 热修复即是一种动态修复技术。

#### 热修复的好处

> 当我们线上产品出现bug时，可以不再重新发版，而直接通过热修复就可以实现应该bug的修复。

#### 

## 常见的热修复框架

AndFix-> 阿里系

Tinker -> 腾讯系

。。。



#### Tinker是什么？

- 基于 android 原生的ClassLoader,开发了自己的ClassLoader
- 基于 android 原生的aapt,开发了自己的aapt
- DexDiff算法，通过比较Dex差异，然后合成新的Dex











