



### 引言

当你认定一些事情的时候，那么在不久的将来，它可能就是未来。

从Flutter到Componse, 对于原生开发，似乎越来越快的进入了一个共性，那就是 [ 声明式 ] 。



## 什么是命令式编程？

让我们先来看一下Android端 UI[工具] 的进化之路：

| 名字                | 时间                  | 主要用途                                 | 优点                                     | 缺点                                                         |
| ------------------- | --------------------- | ---------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| findViewById        | 从最开始到现在        | 显示拿到一个view对象                     | 随用随取，简单通用                       | 空指针风险，频繁findxxx影响性能                              |
| Kotlin-Synthetics   | 2017-2020(目前已废弃) | 通过xml直接拿到view对象                  | 不必再显式findxx,有缓存                  | 空指针风险，内部依然需要findxx一次，仅支持kotlin             |
| DataBinding(声明式) | 2017-至今             | 双向绑定(代码格式)                       | null安全，类型安全，编译速度快，双向绑定 | 复杂度提高，不利于问题排查                                   |
| ViewBinding         | 2019-至今             | 目的是尽可能干掉findViewById和其他注解库 | null安全，类型安全，编译速度快           | 相比DataBinding,不支持布局变量与布局表达式，不支持双向数据绑定 |

但无论上述改变多少，我们依然可以通过 命令式的写法去更新，比如DataBinding中的bing，尽管我们已经禁止非必要情况下获取bind对象，但实际上我们依然可以拿到，并且手动更新。

长期以来，Android 的视图结构一直以xml这种界面树来表示，但由于应用的状态会因为用户的交互等因素而发生改变，因此界面层次结构需要进行更新以显示当前数据。

#### 命令式编程的隐患

手动操作UI的方式会提高出错的可能性，因为状态无法唯一，很容易造成异常状态。



## 什么是声明式编程？

对于屏幕上的元素，也就是View来说，本身是不可被改变的，当因为用户的状态而将要发生改变时，不会再像之前一样，改变旧的View，而是整个View全部重新绘制，即重新构建了当前界面。当然这也意味着对性能的极大挑战。

### Flutter如何处理性能问题？



### Compose如何处理性能问题？

为了减轻重绘的成本，Compose会智能的选择在任何给定时间需要重新绘制界面的那些部分。

可以理解为，框架会根据 数据 的变化重新绘制View，当然Compose大多数情况下只会智能重绘数据变化过的组件，其他没有受到影响的组件不会再次重绘，我们将上述这个过程称为 **重组**



## Componse中的重组到底是什么？

在命令式界面的模型中，当我们要更改某个view或者元素时，我们可以直接调用相应的set方法实现，在Compose中，我们直接更改新数据后再次调用可组合函数即可，这样做会导致函数进行重组，系统会根据需要使用新数据智能的重新绘制函数。

#### 组合函数可以任意顺序执行

当某个函数方法包含了对其他可组合函数的调用，这些函数可以以任何顺序运行。Compose可以选择识别出某些界面元素的优先级是否高于其他界面元素，从而首先绘制这些元素。

#### 组合函数可以并行运行

Compose可以并行运行组合函数，从而来优化界面重组的过程。同时这也意味着，Compose可以利用我们多个核心，从而也可能会从后台线程池中执行。

调用某个可组合函数时，因为调用可能发生在不同的线程，所以开发者应该尽可能避免使用 可组合函数中lambda的变量。

#### 重组会跳过尽可能多的内容

![image-20210310211002508](https://tva1.sinaimg.cn/large/008eGmZEgy1gof47wkbycj30uq0u014w.jpg)

如上图所示，作用域中的每一个都可能是在重组期间执行的唯一一个作用域，当header发生更改时，Compose可能会跳至 **Column** lambda,而不执行它的任何父项。另外，执行 `Column` 时，如果 `names` 没有更改，Compose 可能会选择跳过 `LazyColumn`

需要注意的是：对于所有可组合函数或者 lambda来说，我们都应该不包含附带效果。如果需要添加附带效果，应通过回调触发。

#### 重组是乐观的操作

只要Compose认为某个可组合函数的参数已发生改变，就会开始重组。Compose会在参数再次发生更改之前完成重组，如果某个参数在重组完成之前又发生更改，Compose可能会取消重组，并且使用新参数重新开始。

当取消重组后，Componse 会从重组中舍弃界面树。如果有任何附带效应依赖于显示的界面，则即使取消了组成操作，也会应用该附带效果，这可能会导致应用的状态不一致。

#### 可组合函数可以非常频繁的运行

在某些情况下，比如在动画中频繁调用组合函数，如果该函数的执行成本较高昂，比如从设备存储空间读取数据，可能会导致界面卡顿。

所以如果可组合函数需要数据，应该为改数据定义参数，并且将一些比较耗费时间的操作移动到非UI线程，并使用 `mutableStateOf` 或 `LiveData` 将相应的数据传递给Compose.

